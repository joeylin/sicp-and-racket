# P1-P39

## I. 对过程的抽象

### Programming in Lisp

**计算过程(computational process)**是存活在计算机里的**抽象事物**，可以操控另一种抽象事物：**数据(data)**，**过程**的演变是由一系列规则所指导的，这些规则称为**程序(program)**。

我们用 `Lisp(LISt Processing)` 语言描述、表达**过程**，Lisp 处理的数据对象被称为**原子和列表(atoms and lists)**。

Why Lisp?

> the language possesses unique features that make it an excellent medium for studying important programming constructs and data structures and for relating them to the linguistic features that support them.

Lisp 最突出的特征是：它对**过程**的描述，称为**程序(procedures)**，其本身可以当做**数据**来表征、操作。

> From 1.2: A procedure is a pattern for the _local evolution_ of a computational process.

## 1.1 The Elements of Programming

好的语言应该可以当做一个框架(framework)，我们可以在这个框架中组织我们关于**过程**的想法。每一门好的语言都能够提供以下三种机制（元素），来帮助我们实现将简单的想法组合成复杂的想法：

1. 基本表达式：用于表达这门语言所关注的**最简单的实体(simplest entities)**，
2. 组合方法：简单的元素可以通过这种组合方法构成**复合的元素(compound elements)**，
3. 抽象方法：复合的元素可以通过抽象的方法，当做独立的**单元(units)**被命名、操作。

**数据(data)**和**过程(procedures)**是我们在程序设计中需要处理（操作）的两个基本元素，**数据**是我们希望处理的东西，而**过程**是我们用以描述以什么样的规则去处理数据的东西。

### 1.1.1 表达式(Expressions)

以简单的数字作为**数据**的例子，数字表达式可以与表达基本过程的表达式(如 + 或 *)组合成复杂的表达式，这一复合表达式可以表示将这些**过程(过程)**应用到**数字(数据)**上。

    (+ 10 5)
    15

用**括号**包围起来的一组表达式的列表(a list of expressions)，组成一个**复合表达式(combinations)**，其中最左边的称为**操作符(operator)**，其它的称为**操作对象(operands)**。

### 1.1.2 Naming and the Environment

我们用名称指代要计算的对象，我们赋予**变量(variable)**以名称，其**值(value)**是计算对象。

    (define size 2)
    size
    2

`define` 是 Lisp 中最简单的**抽象方法**，它允许我们为复合操作的结果指定简单的名称。

Lisp 解释器能够将对象的值与其符号名称联系起来，并可以在后续的操作中重新根据符号名称寻回该对象的值，说明 Lisp 解释器一定保存某种形式的**记忆(memory)**用于保持追踪这些名称-对象的组合，这种记忆被称为**环境(environment，更精确地说，是全局环境 global environment)**。

### 1.1.3 Evaluating Combinations(对复合表达式求值)

对复合表达式求值按照如下两个步骤：

1. 对每一个子表达式(subexpressions)求值;
2. 将最左边的操作符应用到各个子表达式的值所组成的操作对象上。

这一求值规则在本质上是一个**递归(recursive)**的过程，因为在其步骤中，又调用了这两个规则本身。当第一个步骤递归到基本表达式的情况时，依照如下约定进行求值：

1. 数字的值是数字所代表的值本身，
2. 内置的操作符完成相应的机器指令序列，
3. 具有其它名称的对象，其值从全局环境中获取。

注意`(define x 3)`的求值并非将`define`操作应用与`x 3`两个参数上，而是关联`x`的值为`3`，这类特例称为**特殊形式(special forms)**。

### 1.1.4 Compound Procedures(复合过程)

至此我们已经定义了 Lisp 中如下几个元素：

1. 数字和算术操作符分别是基本数据和基本过程；
2. 嵌套组合提供复合操作的方法；
3. 一种可以将名字与值联系到一起的简单抽象方法(`define`)。

Lisp 的另外一种更强大的抽象技术可以赋予一组复合操作以名字并当做一个整体单元来操作，称为**过程定义(procedure definitions)**：

    (define (<name> <formal parameters>)
        <body>)

过程定义与变量的定义类似，是将一系列复合操作(`<body>`)命名为某个复合操作名称(`(<name> <formal parameters>)`)，例如

    (define (square x) (* x x))
    (square 5)
    25
    
复合过程可以与基本过程一样使用，如`square`与`+`或`*`，甚至从表面上无法判断谁是复合过程，谁是基本过程。

### 1.1.5 过程应用的替换模型

将复合过程应用到实际参数上，需要将定义中的形参(formal parameters)替换成相应的实际参数，这一过程称为过程应用的**替换模型(substitution model)**，这一模型可以帮助我们理解过程的应用而非描述解释器实际工作的过程；后续章节将会出现越来越多更加复杂的模型，直至完整地实现解释器。

**1.1.3 对复合表达式求值**中提出的求值步骤先计算操作符与操作对象的值，然后将结果所得到的过程应用到计算结果所得到的参数中，然而这并不是方法，另一种方法不会先计算操作对象，而是一直等到它们不得不计算才计算其结果，如：

    (define (sum-of-squares x y) (+ (square x) (square y)))
    (sum-of-squares (+ 5 1) (* 5 2))
    (+ (square (+ 5 1)) (square (* 5 2)))
    (+ (* (+ 5 1) (+ 5 1)) (* (* 5 2) (* 5 2)))
    ; + 5 1 已经到了不得不计算的地步，然后开始回收
    (+ (* 6 6) (* 10 10))
    (+ 36 100)
    136

这种“先全部展开然后再逐步回收”的方法称为**正常序求值(normal-order evaluation)**，之前1.1.3中“先计算所有参数再应用过程”的方法称为**应用序(applicative-order evaluation)**。凡是符合替换模型并且能够产出合法值的过程，正常序与应用序的计算结果应该是相同的。

### 1.1.6 条件表达式和谓词(Conditional Expressions and Predicates)

`cond`与`define`一样也是Lisp的一个**特殊形式**，**它定义的过程可以根据结果的不同采取不同的计算过程**，条件表达式的一般形式为：

    (cond (<p1> <e1>)
          (<p2> <e2>)  
          ...
          (<pn> <en>))
          
其中每一对`(<p> <e>)`称为`cond`的**子句(clauses)**，`p`代表谓词(predicate)，谓词表达式的值会被解读为逻辑真或逻辑假。`cond`依次判断子句中的谓词的计算结果，如果为真则`cond`的值就是该条子句中的表达式(`<e>`)的值，如果所有谓词均为假，则`cond`的值为`undefined`。

    (define (abs x)
        (cond ((< x 0) (- x))
                (else x)))
    ; 事实上任何永远为真的表达式都可以用来取代 else
    
当只有两种判断条件时，可以用另外一种特殊形式：`if`，如

    (define (abs-if x)
        (if (< x 0) 
            (- x)
            x))
            
`if`表达式的一般形式为：`(if <谓词> <谓词为真的结果> <谓词为假的结果>)`。

除了**基本谓词**如`< = >`之外，Lisp 中还有一些由逻辑操作组成的**复合谓词**如下：

    (and <e1> ... <en>)
    ; 从左向右依次计算每一个表达式<e>的值，直到遇到一个值为 false 的表达式，后面的表达式不再计算，and 复合语句的值将为 false；
    ; 如果所有表达式<e>的值均为真，则 and 复合语句的值为最后一个表达式<en>的值。
    
    (or <e1> ... <en>)
    ; 从左向右以此计算每一个表达式<e>的值，直到遇到一个值为 true 的表达式，后面的表达式不再计算，or 复合语句的值将为 true；
    ; 如果所有表达式<e>的值均为假，则 or 复合语句的值为假。
    
    (not <e>)
    ; not is not here.
    
注意这里 `and` 和 `or` 都不是过程而是特殊形式，因为其子语句并不一定被求值，而`not`是正常的过程。

> 疑问：

> 过程(procedure)与特殊形式(special form)有何区别？

> 试答：过程是指对数据操作（求值）的规则的描述，且必须对所有数据进行求值(?)，过程更像是数学公式，其值取决于参数；而特殊形式有自身特别的求值规则，并不要求一定要对数据求值。另外练习1.6中可以看到，普通的过程与特殊形式的差异，当解释器采用应用序进行求值的时候，过程应用的所有参数会先进行求值，而特殊形式则不用，因为它们有自己的求值规则。
                

### 1.1.7 实例：牛顿法求平方根
    
数学函数与过程之间的区别就像**陈述性知识(declarative knowledge)**与**程序性知识(Procedural knowledge/imperative knowledge)**之间的区别，一个告诉你是什么，一个告诉你怎么做。

### 1.1.8 过程黑箱

过程的含义应该与其参数的名称无关，因此形式参数的定义应该局限在过程体的范围内，这些形参的名称称为**约束变量(bound variable)**，过程的定义则是绑定(binds)到他的形参上的，统一更改所有形参，理应对过程的定义没有影响。

（过程中）没有被绑定的变量称为**自由变量(free)**，绑定、约束变量的一系列表达式的集合称为该变量的**作用域(scope)**。
